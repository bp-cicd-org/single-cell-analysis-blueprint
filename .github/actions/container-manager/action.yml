name: 'Container Lifecycle Manager'
description: 'Manages Docker container lifecycle with intelligent start/stop/status operations'

inputs:
  action:
    description: 'Action to perform: start, stop, restart, status, logs, exec, prepare'
    required: true
  compose-file:
    description: 'Docker compose file path'
    required: true
  service-name:
    description: 'Service name to manage'
    required: false
    default: 'backend'
  wait-timeout:
    description: 'Wait timeout for container readiness in seconds'
    required: false
    default: '300'
  environment-vars:
    description: 'Additional environment variables (JSON format)'
    required: false
    default: '{}'
  image-tag:
    description: 'Docker image tag to use'
    required: false
  host-path:
    description: 'Host path to mount'
    required: false
  command:
    description: 'Command to execute (for exec action)'
    required: false
  user:
    description: 'User to run command as (for exec action)'
    required: false
    default: 'rapids'
  working-dir:
    description: 'Working directory for exec command'
    required: false
    default: '/home/rapids'
  log-lines:
    description: 'Number of log lines to retrieve'
    required: false
    default: '200'
  enable-debug:
    description: 'Enable debug output'
    required: false
    default: 'false'

outputs:
  container-id:
    description: 'Container ID'
    value: ${{ steps.get-container-info.outputs.container_id }}
  container-status:
    description: 'Container status'
    value: ${{ steps.get-container-info.outputs.container_status }}
  start-time:
    description: 'Container start time in seconds'
    value: ${{ steps.start-container.outputs.start_time }}
  operation-time:
    description: 'Time taken for operation in seconds'
    value: ${{ steps.track-time.outputs.operation_time }}
  logs-file:
    description: 'Path to logs file (if logs action)'
    value: ${{ steps.get-logs.outputs.logs_file }}

runs:
  using: "composite"
  steps:
    - name: Setup Docker Compose compatibility
      id: setup-compose
      shell: bash
      run: |
        echo "INFO: Setting up Docker Compose compatibility layer..."
        
        # Create compatibility detection function
        cat > /tmp/compose-compat.sh << 'EOF'
        #!/bin/bash
        
        # Smart Docker Compose compatibility detection
        detect_compose_cmd() {
          local compose_cmd=""
          local file_flag=""
          
          # Test docker compose (plugin) first
          if docker compose version >/dev/null 2>&1; then
            if docker compose --help 2>/dev/null | grep -q "\-\-file"; then
              compose_cmd="docker compose"
              file_flag="--file"
              echo "INFO: Using 'docker compose' with '--file' flag" >&2
            elif docker compose --help 2>/dev/null | grep -q "\-f"; then
              compose_cmd="docker compose"
              file_flag="-f"
              echo "INFO: Using 'docker compose' with '-f' flag" >&2
            fi
          fi
          
          # Fallback to standalone docker-compose
          if [ -z "$compose_cmd" ] && command -v docker-compose >/dev/null 2>&1; then
            if docker-compose --help 2>/dev/null | grep -q "\-\-file"; then
              compose_cmd="docker-compose"
              file_flag="--file"
              echo "INFO: Using 'docker-compose' with '--file' flag" >&2
            else
              compose_cmd="docker-compose"
              file_flag="-f"
              echo "INFO: Using 'docker-compose' with '-f' flag" >&2
            fi
          fi
          
          # Validate we found a working command
          if [ -z "$compose_cmd" ]; then
            echo "ERROR: No working Docker Compose command found" >&2
            echo "Available commands:" >&2
            command -v docker && echo "  - docker: $(docker version --format '{{.Client.Version}}' 2>/dev/null || echo 'unknown')" >&2
            command -v docker-compose && echo "  - docker-compose: $(docker-compose --version 2>/dev/null || echo 'unknown')" >&2
            return 1
          fi
          
          # Export for use in subsequent commands
          echo "COMPOSE_CMD=$compose_cmd" >> $GITHUB_ENV
          echo "COMPOSE_FILE_FLAG=$file_flag" >> $GITHUB_ENV
          
          echo "SUCCESS: Using command: $compose_cmd $file_flag" >&2
          return 0
        }
        
        # Execute detection
        detect_compose_cmd
        EOF
        
        # Make script executable and run it
        chmod +x /tmp/compose-compat.sh
        source /tmp/compose-compat.sh
        
        # Verify environment variables were set
        echo "Detected compose command: $COMPOSE_CMD"
        echo "Detected file flag: $COMPOSE_FILE_FLAG"
        
        # Output for other steps
        echo "compose_cmd=$COMPOSE_CMD" >> $GITHUB_OUTPUT
        echo "file_flag=$COMPOSE_FILE_FLAG" >> $GITHUB_OUTPUT
    - name: Validate inputs
      shell: bash
      run: |
        if [ -z "${{ inputs.compose-file }}" ]; then
          echo "ERROR: compose-file is required"
          exit 1
        fi
        
        if [ ! -f "${{ inputs.compose-file }}" ]; then
          echo "ERROR: Compose file not found: ${{ inputs.compose-file }}"
          exit 1
        fi
        
        VALID_ACTIONS="start stop restart status logs exec prepare"
        if ! echo "$VALID_ACTIONS" | grep -q "\b${{ inputs.action }}\b"; then
          echo "ERROR: Invalid action '${{ inputs.action }}'. Valid actions: $VALID_ACTIONS"
          exit 1
        fi
        
        if [ "${{ inputs.enable-debug }}" = "true" ]; then
          echo "DEBUG: Action: ${{ inputs.action }}"
          echo "DEBUG: Compose file: ${{ inputs.compose-file }}"
          echo "DEBUG: Service: ${{ inputs.service-name }}"
        fi

    - name: Track operation time
      id: track-time
      shell: bash
      run: |
        start_time=$(date +%s)
        echo "start_time=${start_time}" >> $GITHUB_OUTPUT

    - name: Setup environment variables
      shell: bash
      run: |
        # Set up standard environment variables
        if [ -n "${{ inputs.image-tag }}" ]; then
          export DOCKER_IMG_TAG="${{ inputs.image-tag }}"
          echo "DOCKER_IMG_TAG=${{ inputs.image-tag }}" >> $GITHUB_ENV
        fi
        
        if [ -n "${{ inputs.host-path }}" ]; then
          export NOTEBOOKS_HOST_PATH="${{ inputs.host-path }}"
          echo "NOTEBOOKS_HOST_PATH=${{ inputs.host-path }}" >> $GITHUB_ENV
        fi
        
        # Set compose timeout
        export COMPOSE_HTTP_TIMEOUT=${{ inputs.wait-timeout }}
        echo "COMPOSE_HTTP_TIMEOUT=${{ inputs.wait-timeout }}" >> $GITHUB_ENV

    - name: Start container
      id: start-container
      if: inputs.action == 'start' || inputs.action == 'restart'
      shell: bash
      run: |
        start_time=$(date +%s)
        
        # Use detected compose command
        echo "INFO: Using compose command: $COMPOSE_CMD $COMPOSE_FILE_FLAG"
        
        if [ "${{ inputs.action }}" = "restart" ]; then
          echo "INFO: Stopping existing containers first..."
          $COMPOSE_CMD $COMPOSE_FILE_FLAG "${{ inputs.compose-file }}" down
        fi
        
        echo "INFO: Starting container with compose file: ${{ inputs.compose-file }}"
        
        if [ "${{ inputs.enable-debug }}" = "true" ]; then
          echo "DEBUG: Current docker images:"
          docker images -a
          echo "DEBUG: Environment variables:"
          env | grep -E "(DOCKER_IMG_TAG|NOTEBOOKS_HOST_PATH|COMPOSE_HTTP_TIMEOUT)"
          echo "DEBUG: Current directory contents:"
          pwd && ls -al ./
          echo "DEBUG: Compose command: $COMPOSE_CMD $COMPOSE_FILE_FLAG"
        fi
        
        set -e
        echo "INFO: Starting containers with $COMPOSE_CMD..."
        
        # Remove --wait flag as it's not supported in older docker-compose versions
        # Use separate health checking logic instead
        if ! $COMPOSE_CMD $COMPOSE_FILE_FLAG "${{ inputs.compose-file }}" up -d --force-recreate; then
          echo "ERROR: Failed to start containers"
          echo "INFO: Attempting to get more details..."
          $COMPOSE_CMD $COMPOSE_FILE_FLAG "${{ inputs.compose-file }}" logs || true
          exit 1
        fi
        
        echo "SUCCESS: Docker Compose up command completed"
        
        # Wait for containers to start and be ready
        echo "INFO: Waiting for containers to start and be ready..."
        
        # First, wait for container to be created and running
        echo "INFO: Step 1 - Waiting for container to be running..."
        CONTAINER_RUNNING=false
        MAX_START_WAIT=120  # 2 minutes for container to start
        START_INTERVAL=5    # Check every 5 seconds
        START_ELAPSED=0
        
        while [ $START_ELAPSED -lt $MAX_START_WAIT ] && [ "$CONTAINER_RUNNING" = "false" ]; do
          echo "Checking container status... (${START_ELAPSED}s elapsed)"
          
          # Check if any containers are running
          RUNNING_CONTAINERS=$($COMPOSE_CMD $COMPOSE_FILE_FLAG "${{ inputs.compose-file }}" ps -q 2>/dev/null | wc -l)
          if [ "$RUNNING_CONTAINERS" -gt 0 ]; then
            # Check specific service
            if $COMPOSE_CMD $COMPOSE_FILE_FLAG "${{ inputs.compose-file }}" ps "${{ inputs.service-name }}" 2>/dev/null | grep -q "Up"; then
              echo "SUCCESS: Container ${{ inputs.service-name }} is running"
              CONTAINER_RUNNING=true
              break
            else
              echo "Container exists but not yet running..."
            fi
          else
            echo "No containers running yet..."
          fi
          
          sleep $START_INTERVAL
          START_ELAPSED=$((START_ELAPSED + START_INTERVAL))
        done
        
        if [ "$CONTAINER_RUNNING" = "false" ]; then
          echo "ERROR: Container did not start within ${MAX_START_WAIT} seconds"
          echo "All containers status:"
          $COMPOSE_CMD $COMPOSE_FILE_FLAG "${{ inputs.compose-file }}" ps || true
          echo "Container logs:"
          $COMPOSE_CMD $COMPOSE_FILE_FLAG "${{ inputs.compose-file }}" logs || true
          exit 1
        fi
        
        # Step 2 - Wait for service to be ready inside container
        echo "INFO: Step 2 - Waiting for services inside container to be ready..."
        SERVICE_READY=false
        MAX_SERVICE_WAIT=180  # 3 minutes for services to be ready
        SERVICE_INTERVAL=10   # Check every 10 seconds
        SERVICE_ELAPSED=0
        
        while [ $SERVICE_ELAPSED -lt $MAX_SERVICE_WAIT ] && [ "$SERVICE_READY" = "false" ]; do
          echo "Checking service readiness... (${SERVICE_ELAPSED}s elapsed)"
          
          # Check if we can exec into container and find running services
          if $COMPOSE_CMD $COMPOSE_FILE_FLAG "${{ inputs.compose-file }}" exec -T "${{ inputs.service-name }}" bash -c 'echo "Container exec test successful" && ps aux | grep -E "(jupyter|python)" | grep -v grep | head -3' >/dev/null 2>&1; then
            echo "SUCCESS: Services are running inside container"
            SERVICE_READY=true
            break
          else
            echo "Services are starting inside container..."
          fi
          
          sleep $SERVICE_INTERVAL
          SERVICE_ELAPSED=$((SERVICE_ELAPSED + SERVICE_INTERVAL))
        done
        
        if [ "$SERVICE_READY" = "false" ]; then
          echo "WARNING: Services did not become ready within ${MAX_SERVICE_WAIT} seconds"
          echo "Container is running but services may still be starting"
        fi
        
        echo "INFO: Container startup process completed"
        
        end_time=$(date +%s)
        start_duration=$((end_time - start_time))
        echo "SUCCESS: Container started successfully in ${start_duration} seconds"
        echo "start_time=${start_duration}" >> $GITHUB_OUTPUT

    - name: Stop container
      if: inputs.action == 'stop'
      shell: bash
      run: |
        echo "INFO: Stopping containers..."
        echo "INFO: Using compose command: $COMPOSE_CMD $COMPOSE_FILE_FLAG"
        $COMPOSE_CMD $COMPOSE_FILE_FLAG "${{ inputs.compose-file }}" down
        echo "SUCCESS: Containers stopped successfully"

    - name: Get container status
      id: get-container-info
      if: inputs.action == 'status' || inputs.action == 'start' || inputs.action == 'restart'
      shell: bash
      run: |
        echo "INFO: Getting container status..."
        docker ps -a
        
        # Get specific container info
        CONTAINER_ID=$($COMPOSE_CMD $COMPOSE_FILE_FLAG "${{ inputs.compose-file }}" ps -q "${{ inputs.service-name }}" 2>/dev/null || echo "")
        if [ -n "$CONTAINER_ID" ]; then
          CONTAINER_STATUS=$(docker inspect "$CONTAINER_ID" --format='{{.State.Status}}' 2>/dev/null || echo "unknown")
          echo "container_id=${CONTAINER_ID}" >> $GITHUB_OUTPUT
          echo "container_status=${CONTAINER_STATUS}" >> $GITHUB_OUTPUT
          echo "INFO: Container ${{ inputs.service-name }} (ID: ${CONTAINER_ID}) status: ${CONTAINER_STATUS}"
        else
          echo "WARNING: Container ${{ inputs.service-name }} not found"
          echo "container_id=" >> $GITHUB_OUTPUT
          echo "container_status=not_found" >> $GITHUB_OUTPUT
        fi

    - name: Get container logs
      id: get-logs
      if: inputs.action == 'logs' || inputs.action == 'status'
      shell: bash
      run: |
        LOGS_FILE="docker-logs-${{ inputs.service-name }}.txt"
        echo "INFO: Retrieving container logs (last ${{ inputs.log-lines }} lines)..."
        
        if $COMPOSE_CMD $COMPOSE_FILE_FLAG "${{ inputs.compose-file }}" logs --no-color --tail=${{ inputs.log-lines }} "${{ inputs.service-name }}" > "$LOGS_FILE" 2>&1; then
          echo "SUCCESS: Logs saved to $LOGS_FILE"
          echo "logs_file=${LOGS_FILE}" >> $GITHUB_OUTPUT
          
          # Show preview of logs
          echo "INFO: Log preview (first 500KB):"
          head -c 500000 "$LOGS_FILE"
        else
          echo "WARNING: Failed to retrieve logs for service ${{ inputs.service-name }}"
          echo "logs_file=" >> $GITHUB_OUTPUT
        fi

    - name: Prepare container environment
      if: inputs.action == 'prepare'
      shell: bash
      run: |
        echo "INFO: Preparing container environment for service ${{ inputs.service-name }}..."
        
        echo "INFO: Preparing environment for service: ${{ inputs.service-name }}"
        
        # First verify container is running and accessible
        echo "INFO: Verifying container accessibility..."
        
        MAX_RETRIES=15
        RETRY_DELAY=10
        
        for i in $(seq 1 $MAX_RETRIES); do
          echo "Attempt $i/$MAX_RETRIES: Testing container accessibility..."
          
          # Check if container is running first
          if ! $COMPOSE_CMD $COMPOSE_FILE_FLAG "${{ inputs.compose-file }}" ps "${{ inputs.service-name }}" | grep -q "Up"; then
            echo "WARNING: Container is not running (attempt $i/$MAX_RETRIES)"
            if [ $i -lt $MAX_RETRIES ]; then
              echo "Waiting $RETRY_DELAY seconds for container to start..."
              sleep $RETRY_DELAY
              continue
            else
              echo "ERROR: Container is not running after $MAX_RETRIES attempts"
              echo "Container status:"
              $COMPOSE_CMD $COMPOSE_FILE_FLAG "${{ inputs.compose-file }}" ps || true
              echo "Container logs:"
              $COMPOSE_CMD $COMPOSE_FILE_FLAG "${{ inputs.compose-file }}" logs --tail=100 "${{ inputs.service-name }}" || true
              exit 1
            fi
          fi
          
          # Test container exec accessibility
          if $COMPOSE_CMD $COMPOSE_FILE_FLAG "${{ inputs.compose-file }}" exec -T "${{ inputs.service-name }}" echo "Container is accessible" >/dev/null 2>&1; then
            echo "SUCCESS: Container is accessible"
            break
          else
            echo "WARNING: Container not accessible for exec yet (attempt $i/$MAX_RETRIES)"
            if [ $i -lt $MAX_RETRIES ]; then
              echo "Waiting $RETRY_DELAY seconds before retry..."
              sleep $RETRY_DELAY
            else
              echo "ERROR: Container is not accessible after $MAX_RETRIES attempts"
              echo "Container status:"
              $COMPOSE_CMD $COMPOSE_FILE_FLAG "${{ inputs.compose-file }}" ps || true
              echo "Container logs:"
              $COMPOSE_CMD $COMPOSE_FILE_FLAG "${{ inputs.compose-file }}" logs --tail=100 "${{ inputs.service-name }}" || true
              exit 1
            fi
          fi
        done
        
        # Install system packages as root
        echo "INFO: Installing system packages..."
        if ! $COMPOSE_CMD $COMPOSE_FILE_FLAG "${{ inputs.compose-file }}" exec -T -u root "${{ inputs.service-name }}" bash -c '
          set -ex
          apt-get update
          apt-get install -y libxml2-utils
          apt-get clean
        '; then
          echo "ERROR: Failed to install system packages"
          echo "Container logs:"
          $COMPOSE_CMD $COMPOSE_FILE_FLAG "${{ inputs.compose-file }}" logs --tail=100 "${{ inputs.service-name }}" || true
          exit 1
        fi
        
        echo "SUCCESS: System packages installed"
        
        # Setup user environment
        $COMPOSE_CMD $COMPOSE_FILE_FLAG "${{ inputs.compose-file }}" exec -T "${{ inputs.service-name }}" bash <<'EOF'
        set -euxo pipefail
        
        whoami
        pwd
        ls -al ./
        ls -al ./notebooks/ || echo "No notebooks directory found"
        ls -al /tmp/app || echo "No /tmp/app directory found"
        
        # Copy files from /tmp/app if it exists
        if [ -d "/tmp/app" ]; then
          echo "INFO: Copying files from /tmp/app to home directory"
          cp -rf /tmp/app/* /home/rapids/ || echo "WARNING: Failed to copy some files"
          ls -al ./
          ls -al ./notebooks || echo "No notebooks directory found after copy"
        fi
        
        # Upgrade pip
        python -m pip install --upgrade pip --user || echo "WARNING: Failed to upgrade pip"
        
        echo "SUCCESS: Container environment prepared"
        EOF

    - name: Execute command in container
      if: inputs.action == 'exec' && inputs.command != ''
      shell: bash
      run: |
        echo "INFO: Executing command in container ${{ inputs.service-name }}..."
        echo "User: ${{ inputs.user }}"
        echo "Working directory: ${{ inputs.working-dir }}"
        
        # For multi-line commands, use heredoc to preserve formatting and syntax
        if ! $COMPOSE_CMD $COMPOSE_FILE_FLAG "${{ inputs.compose-file }}" exec -T \
          -u "${{ inputs.user }}" \
          -w "${{ inputs.working-dir }}" \
          "${{ inputs.service-name }}" \
          bash <<EXEC_EOF
        ${{ inputs.command }}
        EXEC_EOF
        then
          echo "ERROR: Command execution failed"
          echo "Container status:"
          $COMPOSE_CMD $COMPOSE_FILE_FLAG "${{ inputs.compose-file }}" ps || true
          echo "Container logs:"
          $COMPOSE_CMD $COMPOSE_FILE_FLAG "${{ inputs.compose-file }}" logs --tail=50 "${{ inputs.service-name }}" || true
          exit 1
        fi
        
        echo "SUCCESS: Command executed successfully"

    - name: Calculate operation time
      shell: bash
      run: |
        start_time="${{ steps.track-time.outputs.start_time }}"
        end_time=$(date +%s)
        operation_time=$((end_time - start_time))
        echo "operation_time=${operation_time}" >> $GITHUB_OUTPUT
        echo "INFO: Total operation time: ${operation_time} seconds"

    - name: Summary
      shell: bash
      run: |
        echo "SUMMARY: Container Lifecycle Manager Summary:"
        echo "   Action: ${{ inputs.action }}"
        echo "   Service: ${{ inputs.service-name }}"
        echo "   Compose File: ${{ inputs.compose-file }}"
        
        if [ "${{ inputs.action }}" = "start" ] || [ "${{ inputs.action }}" = "restart" ]; then
          echo "   Container ID: ${{ steps.get-container-info.outputs.container_id }}"
          echo "   Container Status: ${{ steps.get-container-info.outputs.container_status }}"
          echo "   Start Time: ${{ steps.start-container.outputs.start_time }} seconds"
        fi
        
        if [ "${{ inputs.action }}" = "logs" ]; then
          echo "   Logs File: ${{ steps.get-logs.outputs.logs_file }}"
        fi
        
        echo "   Total Operation Time: ${{ steps.track-time.outputs.operation_time }} seconds"
